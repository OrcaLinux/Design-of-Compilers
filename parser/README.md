# **TINY Language Parser**

This project implements a **Parser** for the **TINY Language**, built on top of the lexical analysis provided by the `Scanner`. The parser transforms the tokens produced by the scanner into a **Syntax Tree**, which represents the program's structure for further processing, such as semantic analysis or code generation.

---

## **Overview**

The TINY Language Parser is designed to process source code written in the TINY language. It reads a sequence of tokens generated by the scanner and constructs a **Syntax Tree** that conforms to the grammar of the language.

### **Features**

-   Modular architecture with clear separation between the **Scanner** and the **Parser**.
-   Constructs a **Syntax Tree** for further processing.
-   Error handling for syntax errors in the input program.
-   Easily extendable for additional grammar rules and constructs.

---

## **Project Structure**

```
.
├── Makefile              # Build system for compiling the parser and scanner
├── README.md             # Documentation for the parser
├── parser/
│   ├── include/
│   │   ├── parser.hpp        # Header for the parser
│   │   └── syntax_tree.hpp   # Header for the syntax tree representation
│   └── src/
│       ├── parser.cpp        # Implementation of the parser
│       └── syntax_tree.cpp   # Implementation of the syntax tree
└── scanner/
    ├── include/
    │   ├── scanner.hpp       # Header for the scanner
    │   ├── token.hpp         # Header for tokens
    │   └── token_stream_builder.hpp # Header for managing tokens
    └── src/
        ├── scanner.cpp       # Implementation of the scanner
        ├── token.cpp         # Implementation of the token class
        └── token_stream_builder.cpp # Implementation of the token stream builder
```

---

## **How It Works**

1. **Scanner Phase**:  
   The scanner reads the input source code and converts it into a stream of tokens. These tokens represent individual lexical elements such as keywords, identifiers, operators, and literals.

2. **Parser Phase**:  
   The parser consumes the token stream and applies the grammar rules of the TINY language to construct a **Syntax Tree**.

3. **Syntax Tree**:  
   The syntax tree represents the hierarchical structure of the program. Each node corresponds to a grammar rule or a terminal token.

---

## **Installation and Usage**

### **Build Instructions**

1. Clone the repository:

    ```bash
    git clone https://github.com/OrcaLinux/Design-of-Compilers.git
    cd Design-of-Compilers/parser
    ```

2. Compile the project:
    ```bash
    make
    ```

### **Run the Parser**

To parse a TINY language program, run the following command:

```bash
./parser < input_file.tiny
```

Replace `input_file.tiny` with the path to your TINY language source code.

### **Example Input**

Sample TINY language program:

```tiny
if x < 10 then
    write x;
end
```

### **Output**

The parser will generate a syntax tree representation of the program:

```
IF
├── CONDITION: x < 10
└── THEN:
    └── WRITE x
```

---

## **Development Details**

### **Parser Implementation**

-   The parser uses a recursive descent approach to process tokens.
-   Each grammar rule is implemented as a separate function in `parser.cpp`.

### **Syntax Tree Representation**

-   The `SyntaxTree` class represents the hierarchical structure of the parsed program.
-   Each node in the tree corresponds to a grammar rule or a terminal token.

---

## **Extending the Parser**

To add support for new grammar constructs:

1. Update the grammar rules in `parser.cpp`.
2. Extend the `SyntaxTree` implementation in `syntax_tree.cpp`.

---

## **Contributing**

Contributions are welcome!  
To contribute:

1. Fork the repository.
2. Create a feature branch.
3. Commit your changes and open a pull request.

---

## **License**

This project is licensed under the MIT License. See the `LICENSE` file for details.
